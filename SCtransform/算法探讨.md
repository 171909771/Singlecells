# step1 用poisson分布拟合（细胞测序深度 和 每个细胞count在每个gene）
### 预处理数据
```
pbmc_data=data.frame(pbmc@assays$RNA@counts) 
cell_attr <- data.frame(n_umi = colSums(pbmc_data), n_gene = colSums(pbmc_data > 
                                                                       0))
cell_attr$logumi=log10(cell_attr$n_umi)
```
##### 得到log10的cell umi值（log（细胞测序深度））, cell_attr 如下：
![image](https://user-images.githubusercontent.com/41554601/184563919-6618f358-2886-4a14-ad37-6039da6a0ebf.png)
##### 按照文章要求，取100个细胞来观察
```
cellnames=sample(colnames(pbmc_data),size = 100)
genenames=rownames(pbmc_data[rowSums(pbmc_data[,cellnames]>0)>5,])
dat1=pbmc_data[genenames,cellnames]   # 取100个细胞对应的dataframe
data_step1 <- cell_attr[cellnames, , drop = FALSE]  # 取100个细胞对应的测序深度
model_str <- paste0('y ~ ', paste("log_umi", collapse = ' + '))  # 构建公式：“y ~ log_umi”
```
### 关键步骤
```
fit=apply(dat1,1, function(y){
  fit <- glm(as.formula(model_str), data = data_step1,family = poisson)  # 广义线性回归拟合poisson
  # fit <-qpois_reg(regressor_data, y, 1e-9, 100, 1.0001, TRUE)  C++加速版本
  fit$theta <- as.numeric(x = suppressWarnings(theta.ml(y = y, mu = fit$fitted))) # 用theta.ml找theta
  return(c(fit$theta,fit$coefficients))
})
fit=t(fit)
colnames(fit)[1] <- 'theta'
```
##### fit如下图所示：
![image](https://user-images.githubusercontent.com/41554601/184565525-5ab00b44-8c59-4e08-87d3-175be7455d0f.png)
#### 可以用get_model_pars函数
```
cells_step1=colnames(dat1)
genes_step1=rownames(dat1)
umi=dat1
bin_size=500
method = 'poisson'
theta_given=NULL
theta_estimation_fun = 'theta.ml'
verbosity = 2
model_pars <- get_model_pars(genes_step1, bin_size, umi, model_str, cells_step1,
                             method, data_step1, theta_given, theta_estimation_fun,
                             verbosity)
```
##### model_pars如下图所示，和fit结果一致
![image](https://user-images.githubusercontent.com/41554601/184566346-2fd1d056-5207-477b-8c38-d87089dceeb9.png)

# step2 平滑处理参数
### 预处理
##### 转换theta到dispersion
```
theta_regularization="od_factor"
dispersion_par <- switch(theta_regularization,
                         'log_theta' = log10(model_pars[, 'theta']),
                         'od_factor' = log10(1 + 10^genes_log_gmean_step1 / model_pars[, 'theta']),
                         stop('theta_regularization ', theta_regularization, ' unknown - only log_theta and od_factor supported at the moment'))
```
##### 获取bandwidth 及 ksmooth的x_points
```
genes_log_gmean <- log10(row_gmean(umi, eps = gmean_eps))  # 获取每个基因的几何平均数
genes_log_gmean_step1 <- log10(row_gmean(umi[genes_step1, cells_step1], eps = gmean_eps))
bw <- bw.SJ(genes_log_gmean_step1) * bw_adjust
x_points <- pmax(genes_log_gmean, min(genes_log_gmean_step1))
x_points <- pmin(x_points, max(genes_log_gmean_step1))
o <- order(x_points)
```
##### 整理表格
```
model_pars <- model_pars[, colnames(model_pars) != 'theta']
model_pars <- cbind(dispersion_par, model_pars)
model_pars_fit <- matrix(NA_real_, length(genes), ncol(model_pars), 
                         dimnames = list(genes, colnames(model_pars)))
```
##### 关键步骤skmooth
```
# 平滑处理dispersion
model_pars_fit[o, "dispersion_par"] <- ksmooth(x = genes_log_gmean_step1, 
                                               y = model_pars[, "dispersion_par"], 
                                               x.points = x_points, 
                                               bandwidth = bw, 
                                               kernel = "normal")$y
# 平滑处理截距和斜率
for (i in 2:ncol(model_pars)) {
  model_pars_fit[o, i] <- ksmooth(x = genes_log_gmean_step1, y = model_pars[, i],
                                  x.points = x_points, bandwidth = bw, kernel='normal')$y}
```
###### dispersion转回theta
```
theta <- switch(theta_regularization,
                'log_theta' = 10^model_pars_fit[, 'dispersion_par'],
                'od_factor' = 10^genes_log_gmean / (10^model_pars_fit[, 'dispersion_par'] - 1)
)
model_pars_fit <- model_pars_fit[, colnames(model_pars_fit) != 'dispersion_par']
model_pars_fit <- cbind(theta, model_pars_fit)
```
###### 确定outlier，如有需要查看is_outlier函数，下为连接
- https://github.com/satijalab/sctransform/blob/e9e52a4c90e9590990c025da373af8cf230517b5/R/utils.R  
```
outliers <- apply(model_pars, 2, function(y) is_outlier(y, genes_log_gmean_step1))
outliers <- apply(outliers, 1, any)
attr(model_pars_fit, 'outliers') <- outliers
```
### step3 获得pearson redisual
##### 待理解tcrossprod，和pearson_residual函数意义
```
min_variance=-Inf
bin_ind <- ceiling(x = 1:length(x = genes_step1) / bin_size)
max_bin <- max(bin_ind)
model_pars_final <- model_pars_fit
regressor_data <- model.matrix(as.formula(gsub('^y', '', model_str)), cell_attr)
regressor_data_final=regressor_data
genes_bin <- genes[bin_ind == 1]
mu <- exp(tcrossprod(model_pars_final[genes_bin, -1, drop = FALSE], regressor_data_final))
y <- as.matrix(umi[genes_bin, , drop = FALSE])
res <- matrix(NA_real_, length(genes), nrow(regressor_data_final), dimnames = list(genes, rownames(regressor_data_final)))
res[genes_bin, ]=pearson_residual(y, mu, model_pars_final[genes_bin, 'theta'], min_var = min_variance)
```
### step4 
##### 用残差计算count
```
corrected_data <- matrix(NA_real_, length(genes), nrow(regressor_data), dimnames = list(genes, rownames(regressor_data)))
pearson_residual <- res[genes_bin, ]
coefs <- model_pars_fit[genes_bin, -1]
theta <- model_pars_fit[genes_bin, 1]
mu <- exp(tcrossprod(coefs, regressor_data))
variance <- mu + mu^2 / theta
corrected_data[genes_bin, ] <- mu + pearson_residual * sqrt(variance)
```





