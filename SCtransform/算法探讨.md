主要应用公式<br>
是否是\<br>
![image](https://user-images.githubusercontent.com/41554601/184651812-bd2dca0f-8765-4d37-bbe9-86473c2620ca.png)
#### 第一个是标准化的pearson residual
#### 第二个是拟合后的fitted值
#### 第三个是标准差

# step1 用poisson分布拟合（细胞测序深度 和 每个细胞count在每个gene）
### 预处理数据
```
pbmc_data=data.frame(pbmc@assays$RNA@counts) 
cell_attr <- data.frame(n_umi = colSums(pbmc_data), n_gene = colSums(pbmc_data > 0))
cell_attr$logumi=log10(cell_attr$n_umi)
```
##### 得到log10的cell umi值（log（细胞测序深度））, cell_attr 如下：

<img src="https://user-images.githubusercontent.com/41554601/184563919-6618f358-2886-4a14-ad37-6039da6a0ebf.png" width="375">

##### 按照文章要求，取100个细胞来观察
```
cellnames=sample(colnames(pbmc_data),size = 100)
genenames=rownames(pbmc_data[rowSums(pbmc_data[,cellnames]>0)>5,])
dat1=pbmc_data[genenames,cellnames]   # 取100个细胞对应的dataframe
data_step1 <- cell_attr[cellnames, , drop = FALSE]  # 取100个细胞对应的测序深度
model_str <- paste0('y ~ ', paste("log_umi", collapse = ' + '))  # 构建公式：“y ~ log_umi”
```
### 关键步骤
```
fit=apply(dat1,1, function(y){
  fit <- glm(as.formula(model_str), data = data_step1,family = poisson)  # 广义线性回归拟合poisson
  # fit <-qpois_reg(regressor_data, y, 1e-9, 100, 1.0001, TRUE)  C++加速版本
  fit$theta <- as.numeric(x = suppressWarnings(theta.ml(y = y, mu = fit$fitted))) # 用theta.ml找theta
  return(c(fit$theta,fit$coefficients))
})
fit=t(fit)
colnames(fit)[1] <- 'theta'
```
##### fit如下图所示：
<img src="https://user-images.githubusercontent.com/41554601/184565525-5ab00b44-8c59-4e08-87d3-175be7455d0f.png" width="375">

#### 可以用get_model_pars函数
```
cells_step1=colnames(dat1)
genes_step1=rownames(dat1)
umi=dat1
bin_size=500
method = 'poisson'
theta_given=NULL
theta_estimation_fun = 'theta.ml'
verbosity = 2
model_pars <- get_model_pars(genes_step1, bin_size, umi, model_str, cells_step1,
                             method, data_step1, theta_given, theta_estimation_fun,
                             verbosity)
```
##### model_pars如下图所示，和fit结果一致
<img src="https://user-images.githubusercontent.com/41554601/184566346-2fd1d056-5207-477b-8c38-d87089dceeb9.png" width="375">

# step2 平滑处理参数
### 预处理
##### 转换theta到dispersion
```
theta_regularization="od_factor"
dispersion_par <- switch(theta_regularization,
                         'log_theta' = log10(model_pars[, 'theta']),
                         'od_factor' = log10(1 + 10^genes_log_gmean_step1 / model_pars[, 'theta']),
                         stop('theta_regularization ', theta_regularization, ' unknown - only log_theta and od_factor supported at the moment'))
```
##### 获取bandwidth 及 ksmooth的x_points
```
genes_log_gmean <- log10(row_gmean(umi, eps = gmean_eps))  # 获取每个基因的几何平均数
genes_log_gmean_step1 <- log10(row_gmean(umi[genes_step1, cells_step1], eps = gmean_eps))
bw <- bw.SJ(genes_log_gmean_step1) * bw_adjust
x_points <- pmax(genes_log_gmean, min(genes_log_gmean_step1))
x_points <- pmin(x_points, max(genes_log_gmean_step1))
o <- order(x_points)
```
##### 整理表格
```
model_pars <- model_pars[, colnames(model_pars) != 'theta']
model_pars <- cbind(dispersion_par, model_pars)
model_pars_fit <- matrix(NA_real_, length(genes), ncol(model_pars), 
                         dimnames = list(genes, colnames(model_pars)))
```
##### 关键步骤skmooth
```
# 平滑处理dispersion
model_pars_fit[o, "dispersion_par"] <- ksmooth(x = genes_log_gmean_step1, 
                                               y = model_pars[, "dispersion_par"], 
                                               x.points = x_points, 
                                               bandwidth = bw, 
                                               kernel = "normal")$y
# 平滑处理截距和斜率
for (i in 2:ncol(model_pars)) {
  model_pars_fit[o, i] <- ksmooth(x = genes_log_gmean_step1, y = model_pars[, i],
                                  x.points = x_points, bandwidth = bw, kernel='normal')$y}
```
###### dispersion转回theta
```
theta <- switch(theta_regularization,
                'log_theta' = 10^model_pars_fit[, 'dispersion_par'],
                'od_factor' = 10^genes_log_gmean / (10^model_pars_fit[, 'dispersion_par'] - 1)
)
model_pars_fit <- model_pars_fit[, colnames(model_pars_fit) != 'dispersion_par']
model_pars_fit <- cbind(theta, model_pars_fit)
```
###### 确定outlier，如有需要查看is_outlier函数，下为连接
- https://github.com/satijalab/sctransform/blob/e9e52a4c90e9590990c025da373af8cf230517b5/R/utils.R  
```
outliers <- apply(model_pars, 2, function(y) is_outlier(y, genes_log_gmean_step1))
outliers <- apply(outliers, 1, any)
attr(model_pars_fit, 'outliers') <- outliers
```
### step3 获得pearson redisual
```
min_variance=-Inf
bin_ind <- ceiling(x = 1:length(x = genes_step1) / bin_size)
max_bin <- max(bin_ind)
model_pars_final <- model_pars_fit
regressor_data <- model.matrix(as.formula(gsub('^y', '', model_str)), cell_attr)
regressor_data_final=regressor_data
genes_bin <- genes[bin_ind == 1]
# tcrossprod是矩阵行*列，代表(intercept+beta*theta)
mu <- exp(tcrossprod(model_pars_final[genes_bin, -1, drop = FALSE], regressor_data_final))
y <- as.matrix(umi[genes_bin, , drop = FALSE])
res <- matrix(NA_real_, length(genes), nrow(regressor_data_final), dimnames = list(genes, rownames(regressor_data_final)))
res[genes_bin, ]=pearson_residual(y, mu, model_pars_final[genes_bin, 'theta'], min_var = min_variance)
```
### step4 
##### 用残差计算count
###### 模拟一个数据
```
library(sctransform)
# 得到数据矩阵
dat2=as.matrix(dat1)
vst_out <- vst(dat2, latent_var = c("log_umi"), return_gene_attr = TRUE, method = 'nb',return_cell_attr = TRUE, verbosity = 2)
```
###### 设定数值
```
x=vst_out
cell_attr = x$cell_attr
as_is = FALSE
do_round = TRUE
do_pos = TRUE
scale_factor=NA
verbosity = 2
verbose = NULL
show_progress = NULL
```
###### 整理数据
```
data <- x[['y']]  # 取persion residual矩阵
# 得到log_umi的median值
cell_attr[, x$arguments$latent_var] <- apply(cell_attr[, x$arguments$latent_var, drop=FALSE], 2, function(x) rep(median(x), length(x)))
regressor_data <- model.matrix(as.formula(gsub('^y', '', x$model_str)), cell_attr)
genes <- rownames(data)
# 划分一个一个小bin
bin_size <- x$arguments$bin_size
bin_ind <- ceiling(x = 1:length(x = genes) / bin_size)
max_bin <- max(bin_ind)
corrected_data <- matrix(NA_real_, length(genes), nrow(regressor_data), dimnames = list(genes, rownames(regressor_data)))
# 用其中一个小bin做实验
genes_bin <- genes[bin_ind == 1]
```
###### 关键步骤
```
# 得到pearson_residual，截距、斜率
pearson_residual <- data[genes_bin, ]
coefs <- x$model_pars_fit[genes_bin, -1]
theta <- x$model_pars_fit[genes_bin, 1]
# 计算median值得fitted（mu）
mu <- exp(tcrossprod(coefs, regressor_data))
# 计算方差
variance <- mu + mu^2 / theta
# 关键步骤，逆向算count，查看顶部的公式即可
corrected_data[genes_bin, ] <- mu + pearson_residual * sqrt(variance)
# 取整，并把负值变成0
corrected_data <- round(corrected_data, 0)
corrected_data[corrected_data < 0] <- 0
```
###### count to data，用log1p()函数


