
先得到seurat数据
----
前处理
---
```
library(tidyverse)
library(Seurat)
library(patchwork)
sce=readRDS("data.rds")
# 计算ercc比例
ercc=rownames(sce)[grep("^ercc",rownames(sce),ignore.case = T)]
ercc=substr(ercc[1],0,4)
pbmc <- PercentageFeatureSet(sce, pattern = ercc, col.name = "percent.Ercc")
# 查看表达情况
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA","percent.Ercc"), ncol = 3)
# 设定表达阈值
sce <- subset(pbmc, subset = nFeature_RNA <6000 & nFeature_RNA > 500 & percent.Ercc < 0.3)
# 修改分组情况
levels(sce$orig.ident)=c(paste(rep('Sham',3),sep = '',seq(1,3)),paste(rep('MCAO',3),sep = '',seq(1,3)))
# 根据分组信息进行拆分数据
sce.list <- SplitObject(sce, split.by = "group")
```
开始整合数据
---
    FindIntegrationAnchors中的参数reference代表选择代表样本为模板进行整合，anchor.features为特征性基因进行整合
#### 对不同list进行标准化，方法1，2需要
```
sce.list <- lapply(X = sce.list, FUN = function(x) {
    x <- NormalizeData(x, verbose = FALSE)
    x <- FindVariableFeatures(x, verbose = FALSE)
  })
```
* 如果想要最后结果里面出现特定基因，在SelectIntegrationFeatures下一行添加如下代码,由于是anchor 基因，尽量不要添加
* features=c(features,"Ripk1", "Ptpn6", "Traf6" )  # "Ripk1", "Ptpn6", "Traf6" 为感兴趣基因
##### 方法1: `rPCA` 
##### 大数据整合，用大rPCA和reference
##### 速度更快，需要先对数据进行上面的PCA。切满足下面3个使用条件：
* A substantial fraction of cells in one dataset have no matching type in the other 
* Datasets originate from the same platform (i.e. multiple lanes of 10x genomics) 
* There are a `large number` of datasets or cells to integrate 
```
# 找关键基因
features <- SelectIntegrationFeatures(object.list = sce.list)
# 归一化，并作PCA，rPCA必做
sce.list <- lapply(X = sce.list, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
  })
# 找锚点,reference 把其中2个数据当成参考模板，
anchors <- FindIntegrationAnchors(object.list = sce.list, reference = c(1, 4), reduction = "rpca",
                                  dims = 1:50)
# 设置锚点，整合完成                                    
anchors <- IntegrateData(anchorset = anchors, dims = 1:50)
```
##### 方法2：CCA。使用条件：跨物种，跨方法学 
- https://satijalab.org/seurat/articles/integration_large_datasets.html
##### 缺点：`速度慢`
```
features <- SelectIntegrationFeatures(object.list = sce.list)
anchors <-  FindIntegrationAnchors(object.list = sce.list, anchor.features = features)
sce.integrated <- IntegrateData(anchorset = anchors, dims = 1:50)
```
##### 方法3：SCTransform + 整合
    SCTransform后面一定需要跟PrepSCTIntegration，IntegrateData中必须有normalization.method = "SCT"
```
sce.list <- lapply(X = sce.list, FUN = function(x) {
  x <- SCTransform(object = x , vars.to.regress = "percent.Ercc",  method = "glmGamPoi",conserve.memory = TRUE)
})
features <- SelectIntegrationFeatures(object.list = sce.list, nfeatures = 3000)
#### 如有特定基因，添加下面代码
# features=c(features,"Ripk1", "Ptpn6", "Traf6")
sce.list <- PrepSCTIntegration(object.list = sce.list, anchor.features = features)
sce.list <- lapply(X = sce.list, FUN = RunPCA, features = features)
anchors <-  FindIntegrationAnchors(object.list = sce.list, normalization.method = "SCT",
                                   anchor.features = features, dims = 1:30, reduction = "rpca", k.anchor = 20)
sce.integrated <-IntegrateData(anchorset = anchors, normalization.method = "SCT", dims = 1:30)
# 分群不用sce.integrated <- ScaleData(sce.integrated, verbose = FALSE)，其他一样
```
 
##### 方法4: Atomic sketch integration
- https://satijalab.org/seurat/articles/atomic_integration.html
```
# step1 选5000个代表细胞
atoms.list <- lapply(X = sce.list, FUN = function(x) {
  x <- NormalizeData(x, verbose = FALSE)
  x <- FindVariableFeatures(x, verbose = FALSE)
  x <- LeverageScoreSampling(object = x, num.cells = 5000)
  })

# step2 整合选出的细胞

atoms.list <- lapply(X = atoms.list, FUN = function(x) {
  x <- SCTransform(object = x , vars.to.regress = "percent.Ercc",  method = "glmGamPoi",conserve.memory = TRUE)
})

features <- SelectIntegrationFeatures(object.list = atoms.list)
atoms.merge <- FastRPCAIntegration(object.list = atoms.list, dims = 1:30, normalization.method = "SCT",
                                   anchor.features = features)

atom.reduction <- "integrated_dr"
atoms.merge <- RunUMAP(atoms.merge, reduction = atom.reduction, dims = 1:30, return.model = TRUE)
DimPlot(atoms.merge, group.by = "orig.ident")

# step3 回归到整体
sce.list <- lapply(X = sce.list, FUN = function(x) {
  x <- SCTransform(object = x , vars.to.regress = "percent.Ercc",  method = "glmGamPoi",conserve.memory = TRUE)
  x <- IntegrateSketchEmbeddings(object = x, atom.sketch.object = atoms.merge, atom.sketch.reduction = atom.reduction,
                                      features = features)
  })
## 合并
obj.merge <- merge(sce.list[[1]], sce.list[2:length(sce.list)], merge.dr = "integrated_dr")

## 分群
obj.merge <- RunUMAP(obj.merge, reduction = "integrated_dr", dims = 1:30)
obj.merge <- FindNeighbors(obj.merge,  graph.name = "test",reduction = "integrated_dr", dims = 1:30)
obj.merge <- FindClusters(obj.merge, graph.name = "test", resolution = 1.5)

DimPlot(obj.merge, reduction = "umap", group.by = "orig.ident", shuffle = TRUE, raster = FALSE)
DimPlot(obj.merge, reduction = "umap", label = TRUE, repel = TRUE)

```
 

分群
---
```
sce.integrated <- ScaleData(sce.integrated, verbose = FALSE)
sce.integrated <- RunPCA(sce.integrated, verbose = FALSE)
sce.integrated <- RunUMAP(sce.integrated, dims = 1:50)

immune.combined <- FindNeighbors(sce.integrated, reduction = "pca", dims = 1:30)
immune.combined <- FindClusters(immune.combined, resolution = 0.5)

p1 <- DimPlot(immune.combined, reduction = "umap", group.by = "group")
p2 <- DimPlot(immune.combined, reduction = "umap", label = TRUE, repel = TRUE)
p1 + p2
```
注释
----
```
library(SingleR)
library("celldex")
## 确定什么去注释
annotation=anchors
sce_for_SingleR <- GetAssayData(annotation, slot="data")
clusters=annotation@active.ident
mouseRNA <- MouseRNAseqData()
pred.mouseRNA <- SingleR(test = sce_for_SingleR, ref = mouseRNA, labels = mouseRNA$label.fine,
                         clusters = clusters, de.method="wilcox",
                         assay.type.test = "logcounts", assay.type.ref = "logcounts")
cellType=data.frame(ClusterID=levels(clusters),mouseRNA=pred.mouseRNA$labels)
# 可视化看注释效果
plotScoreHeatmap(pred.mouseRNA, clusters=pred.mouseRNA@rownames, fontsize.row = 9,show_colnames = T)
new.cluster.ids <- pred.mouseRNA$labels
names(new.cluster.ids) <- levels(annotation)
annotation1 <- RenameIdents(annotation,new.cluster.ids)
# 改相应的分布名称TSNE OR UMAP
DimPlot(annotation1, reduction = "umap", label = T)
```
看每个细胞群的基因表达
---
```
library(ggplot2)
library(cowplot)
theme_set(theme_cowplot())
annotation1$celltype.group <- paste(Idents(annotation1), str_sub(annotation1@meta.data[["orig.ident"]],1,4), sep = "_")
annotation1$celltype <- Idents(annotation1)
Idents(annotation1) <- "celltype.group"
# umap图上面的基因表达
FeaturePlot(annotation1, features = c("Ripk1", "Ptpn6", "Traf6"), split.by = "group", max.cutoff = NA,
cols = c("grey", "red"))
# boxplot图
# 可以修改不同的assay和slot
plots <- VlnPlot(annotation1, assay = 'integrated',slot = 'data',features = c("Ripk1", "Ptpn6", "Traf6"), split.by = "celltype.group", group.by = "celltype",
pt.size = 0, combine = FALSE)
wrap_plots(plots = plots, ncol = 1)
```
![image](https://user-images.githubusercontent.com/41554601/185779847-f3dc1833-0ed2-482f-b278-9eaacc4d7f22.png)


提取特定细胞亚群中的细胞簇分析
---
```
## 提取特定细胞亚群,改下面的群的名字
cluster1="Microglia"
cluster2="Astrocytes"
annotation.cluster1.cluster2=subset(annotation1,celltype==cluster1|celltype==cluster2)
## 加入新的meta注释
test=annotation.microglia.astrocyte
test$tmp <- paste(test@meta.data[["celltype"]], test@meta.data[["seurat_clusters"]], sep = "_")
## 画图1
plots <- VlnPlot(test, features = c("Ripk1", "Ptpn6", "Traf6"), split.by = "celltype.group", group.by = "tmp", 
                 pt.size = 0, combine = FALSE)
wrap_plots(plots = plots, ncol = 1)
```
![image](https://user-images.githubusercontent.com/41554601/185724730-6c23a2ec-6bde-449c-b659-d684dec9ee22.png)
```
## 画图2
FeaturePlot(test, features = c("Ripk1", "Ptpn6", "Traf6"),split.by = "group", max.cutoff = NA, 
            cols = c("grey", "red"))
```
![image](https://user-images.githubusercontent.com/41554601/185724745-a276a65c-6bc8-46b5-a7d5-9e648f0d5120.png)





