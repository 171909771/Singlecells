
# 数据前处理 -------------------------------------------------------------------

library(limma)
library(edgeR)
## 归一化
dat <- read.delim('GSE23163_bulk_wholebrain/GSE23163_series_matrix.txt.gz',comment.char = "!")
dat <- data.frame(dat)
dat1 <- dat[-1]
dat1 <- dat1[paste('GSM',c(570185:570188,570197:570200),sep = "")]



dat1=log2(dat1+1)
dat1=data.frame(normalizeBetweenArrays(dat1))





boxplot(dat1)
dat1$ID_REF <- dat$ID_REF

## 注释
annotagse23163 <- data.table::fread("GSE23163_bulk_wholebrain/GPL6885-11608.txt")
annotagse23163_tmp <- annotagse23163[,c(1,28)]
annotagse23163_tmp$GB_ACC <- str_split(annotagse23163_tmp$GB_ACC,'[.]',simplify = T)[,1]
library('biomaRt')
ensembl = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
## instead of using the wildcard ("*") use a vector of genbank accession you are using.
dat = getBM(attributes = c("protein_id", "embl", "hgnc_symbol"), values = "*", mart = ensembl)
annot<-getBM(c("ensembl_gene_id", "mgi_symbol", "refseq_mrna"), mart=ensembl)
dat2 <- merge(dat1,annotagse23163_tmp,by.x='ID_REF',by.y='ID')
dat3 <- merge(dat2,annot,by.x='GB_ACC',by.y='refseq_mrna')
dat4 <-dat3[,3:12] 

dat5 <- aggregate(x = dat4[,1:8],
                 by = list(dat4$mgi_symbol),
                 FUN = mean)
rownames(dat5)=dat5$Group.1
dat5$Group.1=NULL


colnames(dat5) <- c(rep('Sham',4),rep('MCAO',4))
dat1 <- dat5

# P2的表达趋势 -----------------------------------------------------------------
avereps_df  <- t(limma::avereps( t(dat1) , ID = colnames(dat1)))##对相同时间序列的表达值取平均

tmp <- readRDS('meta_cor_mcao24h.rds')
tmp2 <- subset(tmp,V2>0.75)
tmp2 <- tmp2$names

avereps_df <- data.frame(avereps_df)



test <- avereps_df[intersect(rownames(avereps_df),tmp2),]

test <- data.frame(test)
# test <- scale(test)
df <- test
df$genename <- rownames(df)
library(tidyverse)
library(reshape2)
df1 <- melt(df)
df2 <- subset(df1,genename=='P2ry12')
wcl <- group_by(df1,variable) %>% summarise(.,type_mean=mean(value))
library(ggplot2)
# Basic line plot with points
ggplot(data=df1, aes(x=variable, y=value, group=genename)) +
  geom_line()+
  geom_point()
# Change the line type

# ggplot(data=df2, aes(x=variable, y=value, group=genename)) +
#   geom_line()+
#   geom_point()

ggplot(data=wcl, aes(x=variable, y=type_mean,group=1)) +
  geom_line()+geom_point()



ggplot(data=df2, aes(x=variable, y=value,group=1)) +
  geom_line()+geom_point()



# 相关性分析 -------------------------------------------------------------------

## 在meta文件夹下完成
# 获得GSE77986的P2相关矩阵 -------------------------------------------------------
test <- dat1
y.bulk <- as.numeric(test['P2ry12',])
tmp <- cor(y.bulk,t(test))
tmp <- data.frame(t(tmp))
tmp$genenames <- rownames(tmp)
tmp <- tmp[order(tmp$t.tmp.,decreasing = T),]
tmp.bulk <- subset(tmp,t.tmp.>0.8)
cor.bulk.gene <- tmp.bulk$genenames


# 超几何分布比较bulk及singlecell --------------------------------------------------
# https://cran.r-project.org/web/packages/mHG/mHG.pdf
# mhg值相当于p-value，p-value相当于校正p
library(mHG)
minhgeo=function(bulkgene,singlegene,p,n=length(singlegene)){
  bulkgene.p=bulkgene[1:round(length(bulkgene)*p*0.01)]
  singlegene.n=head(singlegene,n)
  tmp= bulkgene.p %in% singlegene.n
  result <- mHG.test(tmp)[["p.value"]]}



# 绘制P值曲线 ------------------------------------------------------------------

library(Seurat)
ref.single <- readRDS('meta_cor_mcao24h.rds')
x1 <- seq(0.6,0.8,0.001)
n <- seq(30,50,5)
y1 <- data.frame(matrix(ncol=3,nrow=0, dimnames=list(NULL, c('bulkprop','singlenumber','p-value'))))

for (k in n) {
  for (i in x1) {
    ref.single8 <- subset(ref.single,V2>i)
    tmp2 <- ref.single8$names
    test=minhgeo(cor.bulk.gene,tmp2,k)
    y2 <- c(k,i,test)
    y1 <- rbind(y1,y2)
  }
}
colnames(y1) <- c('bulkprop','singlenumber','p_value')
y1$bulkprop <- as.character(y1$bulkprop)
p1 <- ggplot(y1,aes(x=singlenumber,y=p_value,color=bulkprop))+geom_line()
library(ggsci)
p1+scale_color_aaas()


