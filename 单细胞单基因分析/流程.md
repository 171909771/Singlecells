SCTransform后，并得到分群信息后
---

### 计算均值
```
gene.mean=apply(annotation1@assays[["SCT"]]@data,1,mean)
gene.mean=sort(gene.mean)
bin_ind <- ceiling(x = 1:length(x = gene.mean) / 762)    # 762 是基因数量除以分群数25
dat1=data.frame('name'=names(gene.mean),'value'=gene.mean,'cluster'=bin_ind)
kk=0
for (i in c(1:25)){
  kk=kk+mean(sample(dat1[dat1$cluster==i,]$value,size=100))
  
}
totalmean=kk/25
```

### 回归分析
```
##### 获得目的分群的dataframe
microglia.nor=subset(annotation1,group=="IS")
microglia.nor=subset(microglia.nor,idents="Astrocytes")
dat.microglia.nor=data.frame(microglia.nor@assays[["SCT"]]@data)
##### 画图看分布
plot(density(as.numeric(dat.microglia.nor['Ripk1',]))  )
##### tweedie分布回归
library(MASS)
library(statmod)
library(pscl)
##### 计算斜率和P值
y1=as.numeric(dat.microglia.nor['Ripk1',])

########## 多核运行
library(parallel)
#第一个函数，申请需要使用的逻辑核心数，cl可以理解为代表申请的逻辑核
cl <- makeCluster(14)
#第二个函数，在每个逻辑核（cl）上加载计算需要用到的R包
clusterEvalQ(cl,library(statmod))
#第三个函数，在每个逻辑核（cl）上加载用到的变量，这里写变量的名字
clusterExport(cl,'y1')

result.tweedie=parApply(cl=cl,X=dat.microglia.nor,MARGIN=1,function(x){
  
  y=glm(y1~x,family=tweedie(var.power=1.1,link.power=0))
  #y=glm.nb(y1~x)
  #y=zeroinfl(y1~x,dist = 'negbin',link ='logit')  # 零膨胀分布
  y2=summary(y)
  return(c(y2$coefficients[2],y2$coefficients[8]))})
result.tweedie=data.frame(t(result.tweedie))
colnames(result.tweedie)=c('slope','P-value')
##### 算adj-p
result.tweedie$adjP=p.adjust(result.tweedie$`P-value`,method = 'BH')
```

### 取cluser的值，并计算中心化的数值
```
##### 排序，取top100的基因
result.tweedie=result.tweedie[order(result.tweedie$adjP,decreasing = F),]
result.tweedie.100=head(result.tweedie,100)
value1=dat1[rownames(result.tweedie.100),]$value
##### 用上面的均值进行scale
meanerror=value1-totalmean
sqrtmean=junfang=sqrt(sum(meanerror^2)/(length(meanerror)))
scalevalue=meanerror/sqrtmean    # scale后的数值
clusterfinal=mean(scalevalue)     # scale后的数值的平均值
```
