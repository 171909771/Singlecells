library(tidyverse)
library(Seurat)
library(patchwork)


annotation1=readRDS('GSE174574postmergeUMAPcluster.rds')
# 太多了不能直接并行，故分批进行
## 数据分批,设置下面的n组,m为需要划分的矩阵行数
n=4
m=17622
gene.mean=NULL
totalmean2=NULL
batch1=cut(seq(1:m),n,c(seq(1:n)))
for (i in 1:n) {
  gene.mean=apply(annotation1@assays[["SCT"]]@data[batch1==i,],1,mean)
  totalmean2=c(totalmean2,gene.mean)
}

gene.mean=sort(totalmean2)
bin_ind <- ceiling(x = 1:length(x = gene.mean) / 705)    # 762 是基因数量除以分群数25
dat1=data.frame('name'=names(gene.mean),'value'=gene.mean,'cluster'=bin_ind)
kk=0
for (i in c(1:25)){
  kk=kk+mean(sample(dat1[dat1$cluster==i,]$value,size=100))
}
totalmean=kk/25


##### 获得目的分群的dataframe
microglia.nor=subset(annotation1,celltype=="Astrocytes")
microglia.nor=subset(microglia.nor,orig.ident=='Sham2'|orig.ident=='Sham1'|orig.ident=='Sham3')
dat.microglia.nor=data.frame(microglia.nor@assays[["SCT"]]@data)
##### 画图看分布
plot(density(as.numeric(dat.microglia.nor['Ptpn6',]))  )
hist(as.numeric(dat.microglia.nor['Ptpn6',]))
##### tweedie分布回归
library(MASS)
library(statmod)
library(pscl)
##### 计算斜率和P值
y1=as.numeric(dat.microglia.nor['Ptpn6',])
library(parallel)
vp_list = c(1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2)
test=lapply(vp_list, function(vp){
  
  cl <- makeCluster(5)
  clusterEvalQ(cl,library(statmod))
  clusterExport(cl,'y1')
  
  result.tweedie=parApply(cl=cl,X=dat.microglia.nor,MARGIN=1,function(x){
    
    y=glm(y1~x,family=tweedie(var.power=vp),start=c(0.5,0.5))
    #y=glm.nb(y1~x)
    #y=zeroinfl(y1~x,dist = 'negbin',link ='logit')  # 零膨胀分布
    y2=summary(y)
    return(c(y2$coefficients[2],y2$coefficients[8]))})
  stopCluster(cl)
  
  result.tweedie=data.frame(t(result.tweedie))
  colnames(result.tweedie)=c('slope','P-value')
  result.tweedie$genename=rownames(result.tweedie)
  
  
  ##### 算adj-p
  result.tweedie$adjP=p.adjust(result.tweedie$`P-value`,method = 'BH')
  result.tweedie=result.tweedie[(result.tweedie$adjP < 0.05 & result.tweedie$slope >0),]
  result.tweedie=na.omit(result.tweedie)
  return(c(vp,result.tweedie))
  
  
})

    

# 取基因相应的数值
AS_sham=sapply(test, function(x1){
  x=data.frame(x1)
  n=nrow(x)
  if (n>=100) {
    x=x[order(x$adjP,decreasing = F),]
    result.tweedie.100=head(x,100)
    value1=dat1[rownames(result.tweedie.100),]$value
  } else {
    value1=dat1[x$genename,]$value
    
  }
  
  ##### 用上面的均值进行scale
  meanerror=value1-totalmean
  sqrtmean=sqrt(sum(meanerror^2)/(length(meanerror)))
  scalevalue=meanerror/sqrtmean    # scale后的数值
  clusterfinal=mean(scalevalue)     # scale后的数值的平均值
  return(c(clusterfinal,x1[[1]],n))
  
})
